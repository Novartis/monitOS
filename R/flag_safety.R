#' High level function to calculate the probability to ensure safety
#'
#' @description This function calculates joint and conditional probabilities
#' of not flagging a safety issue at different analysis stages, assuming that
#' the Tom Fleming monitoring guideline is in place.
#' @param method String. Either "joint" to calculate joint probabilities,
#' i.e., P(Reach analysis stage k and flag a safety issue) or "cond" to
#' calculate conditional probabilities, i.e., P(Flag a safety issue at stage k|
#' have not flagged a safety issue at any precedent analysis 1, ..., k-1).
#' Method "joint" is appropriate to explore at analysis stage, whereas "cond"
#' may be explored when the trial is actually in progress.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed probabilities at each
#' analysis stage.
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res1 <- flag_safety(method='joint', logthres, events, loghr)
#' res2 <- flag_safety(method='cond', logthres, events, loghr)
flag_safety <- function(method = 'joint', logthres, events, loghr) {
  res <- switch(
    method,
    joint = safprob(logthres, events, loghr),
    cond = safprobc(logthres, events, loghr)
  )
  return(as.numeric(res))
}

#' High level function to calculate the probability to flag a safety issue
#'
#' @description This function calculates joint and conditional probabilities
#' of flagging a safety issue at different analysis stages, assuming that
#' the Tom Fleming monitoring guideline is in place.
#' @param method String. Either "joint" to calculate joint probabilities,
#' i.e., P(Reach analysis stage k and flag a safety issue) or "cond" to
#' calculate conditional probabilities, i.e., P(Flag a safety issue at stage k|
#' have not flagged a safety issue at any precedent analysis 1, ..., k-1).
#' Method "joint" is appropriate to explore at analysis stage, whereas "cond"
#' may be explored when the trial is actually in progress.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed probabilities at each
#' analysis stage.
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1.3)
#' res1 <- flag_stop(method='joint', logthres, events, loghr)
#' res2 <- flag_stop(method='cond', logthres, events, loghr)
flag_stop <- function(method = 'joint', logthres, events, loghr) {
  res <- switch(
    method,
    joint = stopprob(logthres, events, loghr),
    cond = stopprobc(logthres, events, loghr)
  )
  return(as.numeric(res))
}


### SUBFUNCTIONS BELOW

#' Joint probability to reach stage k and don't declare a safety issue
#'
#' @description Calculate the joint probability to reach stage k and don't
#' declare a safety issue given the assumed hazard ratio.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed joint probabilities at each
#' analysis stage.
#' @import mvtnorm
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res <- safprob(logthres, events, loghr)
safprob <- function(logthres, events, loghr) {
  nstage <- length(events) # total number of analyses planned
  info <-
    events / 4 # Fisher's information for log-HR at each analysis

  # Calculate the variance-covariance matrix for the sequence of logHR estimates
  mnloghr <- rep(loghr, times = nstage)
  if (nstage > 1) {
    sigma <- mat.or.vec(nr = nstage, nc = nstage)
    diag(sigma) <- 1 / info
    for (i in 1:(nstage - 1)) {
      for (j in (i + 1):nstage) {
        sigma[i, j] <- 1 / info[j]
        sigma[j, i] <- sigma[i, j]
      }
    }
  } else {
    sigma <- matrix(1 / info)
  }

  sprob <- 0
  # Calculate P{Continue to stage k and do not flag a safety signal; log-HR}
  sprob <- pmvnorm(
    lower = rep(-Inf, times = nstage),
    upper = logthres[1:nstage],
    mean = mnloghr,
    sigma = sigma,
    keepAttr = FALSE
  )

  return(as.numeric(sprob))
}


#' Conditional probability to not declare a safety issue at stage k
#'
#' @description Calculate the probability to reach stage k and not declare
#' a safety issue given the assumed true hazard ratio and that a safety issue
#' was not declared at any previous stage.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed conditional probabilities
#' at each analysis stage.
#' @import mvtnorm
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res <- safprobc(logthres, events, loghr)
#'
safprobc <- function(logthres, events, loghr) {
  nstage <- length(events) # total number of analyses planned
  info <-
    events / 4 # Fisher's information for log-HR at each analysis

  # Calculate the variance-covariance matrix for the sequence of log-HR
  # estimates
  mnloghr <- rep(loghr, times = nstage)
  sigma <- mat.or.vec(nr = nstage, nc = nstage)
  diag(sigma) <- 1 / info
  for (i in 1:(nstage - 1)) {
    for (j in (i + 1):nstage) {
      sigma[i, j] <- 1 / info[j]
      sigma[j, i] <- sigma[i, j]
    }
  }

  jpnum <- 0
  jpnum <- pmvnorm(
    lower = rep(-Inf, times = nstage),
    upper = logthres[1:nstage],
    mean = mnloghr,
    sigma = sigma,
    keepAttr = FALSE
  )

  jpdenom <- 0
  jpdenom <- pmvnorm(
    lower = rep(-Inf, times = nstage - 1),
    upper = logthres[1:(nstage - 1)],
    mean = mnloghr[1:(nstage - 1)],
    sigma = sigma[1:(nstage - 1), 1:(nstage - 1)],
    keepAttr = FALSE
  )

  return(as.numeric(jpnum / jpdenom))
}

#' Joint probability to reach stage k and declare a safety concern
#'
#' @description Calculate the joint probability to reach stage k and declare
#' a safety issue given the assumed true hazard ratio.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed probabilities at each
#' analysis stage.
#' @import mvtnorm
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res <- stopprob(logthres, events, loghr)
#'
stopprob <- function(logthres, events, loghr) {
  nstage <- length(events) # total number of analyses planned
  info <-
    events / 4 # Fisher's information for log-HR at each analysis

  # Calculate the variance-covariance matrix for the sequence of log-HR
  # estimates
  mnloghr <- rep(loghr, times = nstage)
  sigma <- mat.or.vec(nr = nstage, nc = nstage)
  diag(sigma) <- 1 / info
  for (i in 1:(nstage - 1)) {
    for (j in (i + 1):nstage) {
      sigma[i, j] <- 1 / info[j]
      sigma[j, i] <- sigma[i, j]
    }
  }

  sprob <- vector(mode = "numeric", length = nstage)
  sprob[1] <-
    pnorm(
      logthres[1],
      mean = mnloghr[1],
      sd = sqrt(sigma[1, 1]),
      lower.tail = FALSE
    )
  for (j in 2:nstage) {
    # Calculate P{Continue to stage k and flag a safety signal; log-HR}
    sprob[j] <-
      pmvnorm(
        lower = c(rep(-Inf, times = (j - 1)), logthres[j]),
        upper = c(logthres[1:(j - 1)], Inf),
        mean = mnloghr[1:j],
        sigma = sigma[1:j, 1:j],
        keepAttr = FALSE
      )
  }

  return(as.numeric(sprob))
}

#' Conditional probability to declare a safety concern at stage k
#'
#' @description Function to calculate the probability to reach stage k and
#' declare a safety issue given the assumed true hazard ratio and that a safety
#' issue was not flagged at any previous stage.
#' @param logthres Vector. The log hazard ratio thresholds for continuation
#' generated by the `bounds` function.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @return Vector. Returns a vector with the computed conditional probabilities
#' at each analysis stage.
#' @import mvtnorm
#' @export
#' @examples
#' logthres <- log(c(1.3, 1))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res <- stopprobc(logthres, events, loghr)
#'
stopprobc <- function(logthres, events, loghr) {
  nstage <- length(events) # total number of analyses planned
  info <-
    events / 4 # Fisher's information for log-HR at each analysis

  # Calculate the variance-covariance matrix for the sequence of logHR estimates
  mnloghr <- rep(loghr, times = nstage)
  sigma <- mat.or.vec(nr = nstage, nc = nstage)
  diag(sigma) <- 1 / info
  for (i in 1:(nstage - 1)) {
    for (j in (i + 1):nstage) {
      sigma[i, j] <- 1 / info[j]
      sigma[j, i] <- sigma[i, j]
    }
  }

  numer <-
    denom <- sprob <- vector(mode = "numeric", length = nstage)
  sprob[1] <-
    pnorm(
      logthres[1],
      mean = mnloghr[1],
      sd = sqrt(sigma[1, 1]),
      lower.tail = FALSE
    )
  for (j in 2:nstage) {
    # Calculate P{Continue to stage k and not flag a safety signal; log-HR}
    numer[j] <- pmvnorm(
      lower = rep(-Inf, times = j),
      upper = logthres[1:j],
      mean = mnloghr[1:j],
      sigma = sigma[1:j, 1:j],
      keepAttr = FALSE
    )

    denom[j] <- pmvnorm(
      lower = rep(-Inf, times = j - 1),
      upper = logthres[1:(j - 1)],
      mean = mnloghr[1:(j - 1)],
      sigma = sigma[1:(j - 1), 1:(j - 1)],
      keepAttr = FALSE
    )
    sprob[j] <- 1 - numer[j] / denom[j]
  }

  return(as.numeric(sprob))
}

#' Probability to declare safety issue but not stop the trial
#'
#' @description Given some pre-specified stopping boundaries, this function to
#' compute the joint probability to reach stage k and declare a safety issue
#' but not stop the trial given the assumed true hazard ratio.
#' @param logthres1 Vector. The log hazard ratio thresholds for flagging a
#' safety issue.
#' @param logthres2 Vector. The log hazard ratio thresholds for stopping the
#' trial due to safety issue.
#' @param events Vector.  A vector with the planned number of events at the
#' analysis stages; `events` should be at least 1.
#' @param loghr Scalar. The assumed true log hazard ratio. Notice that a hazard
#' ratio larger than 1, would favor control (higher survival rates in
#' control) whereas a hazard ratio less than 1 would favor the treatment arm.
#' @import mvtnorm
#' @return Vector. Returns a vector with the computed probabilities at each
#' analysis stage.
#' @export
#' @examples
#' logthres1 <- log(c(1.3, 1))
#' logthres2 <- log(c(1.8, 1.3))
#' events <- c(50, 100)
#' loghr <- log(1)
#' res <- flagprob(logthres1, logthres2, events, loghr)
flagprob <- function(logthres1, logthres2, events, loghr = log(1)) {
  nstage <- length(events) # total number of analyses planned
  info <-
    events / 4 # Fisher's information for log-HR at each analysis

  # Calculate the variance-covariance matrix for the sequence of log-HR
  # estimates
  mnloghr <- rep(loghr, times = nstage)
  sigma <- mat.or.vec(nr = nstage, nc = nstage)
  diag(sigma) <- 1 / info
  for (i in 1:(nstage - 1)) {
    for (j in (i + 1):nstage) {
      sigma[i, j] <- 1 / info[j]
      sigma[j, i] <- sigma[i, j]
    }
  }

  sprob <- vector(mode = "numeric", length = nstage)
  sprob[1] <-
    pnorm(logthres2[1], mean = mnloghr[1], sd = sqrt(sigma[1, 1])) -
    pnorm(logthres1[1], mean = mnloghr[1], sd = sqrt(sigma[1, 1]))

  for (j in 2:nstage) {
    # Calculate P{Continue to stage k and flag a safety signal but not suggest
    # stopping the trial; log-HR}
    sprob[j] <-
      pmvnorm(
        lower = c(rep(-Inf, times = (j - 1)), logthres1[j]),
        upper = c(logthres1[1:(j - 1)], logthres2[j]),
        mean = mnloghr[1:j],
        sigma = sigma[1:j, 1:j],
        keepAttr = FALSE
      )
  }

  return(as.numeric(sprob))
}
